<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>RNT Energy Coverage Viewer (Zones A–D)</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <link rel="stylesheet" href="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.css" />
  <script src="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.js"></script>
  <style>
    html, body { height: 100%; margin: 0; }
    #map { height: 100%; }
    .panel {
      position: absolute; right: 10px; top: 10px; z-index: 1000;
      background: #fff; padding: 12px; border-radius: 10px; width: 360px;
      box-shadow: 0 8px 30px rgba(2, 8, 20, .15); font: 13px/1.35 system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Arial, sans-serif;
      max-height: calc(100vh - 20px); overflow: auto;
    }
    .panel h3 { margin: 0 0 8px; font-size: 16px; }
    .panel h4 { margin: 14px 0 6px; font-size: 13px; opacity: .85; }
    .row { display: grid; grid-template-columns: 1fr auto; gap: 8px; align-items: center; margin: 6px 0; }
    .row > label { grid-column: 1 / span 2; font-weight: 600; opacity: .85; }
    .row > input[type="text"], .row > input[type="number"], .row > select, .row > textarea {
      grid-column: 1 / span 2; padding: 8px 10px; border-radius: 8px; border: 1px solid #e4e7ec; outline: none;
    }
    .row > input[type="file"] { grid-column: 1 / span 2; }
    .row .btn { padding: 8px 10px; border-radius: 8px; border: 1px solid #d0d5dd; cursor: pointer; background: #f8fafc; }
    .row .btn.primary { background: #0ea5e9; color: #fff; border-color: #0ea5e9; }
    .small { font-size: 12px; opacity: .8; }
    .legend {
      position: absolute; left: 10px; bottom: 10px; z-index: 1000;
      background: #fff; padding: 10px; border-radius: 10px; box-shadow: 0 8px 30px rgba(2,8,20,.15);
      font: 12px/1.35 system-ui, sans-serif;
    }
    .legend .item { display: flex; align-items: center; gap: 8px; margin: 6px 0; }
    .swatch { width: 14px; height: 14px; border-radius: 4px; border: 1px solid #d0d5dd; }
    .pill { display:inline-block; padding: 2px 8px; border-radius: 999px; font-size: 12px; border:1px solid #e5e7eb; }
    details { border: 1px dashed #e5e7eb; padding: 8px 10px; border-radius: 8px; }
    summary { cursor: pointer; font-weight: 600; }
    .hr { height: 1px; background: #eee; margin: 10px 0; }
  </style>
</head>
<body>
  <div id="map"></div>

  <div class="panel">
    <h3>RNT Energy Coverage Viewer</h3>
    <div class="small">Overlay the RNT PNG on a simple CRS map, add locations, and classify Zone A–D to guide Banking Agents deployment.</div>

    <h4>1) Base map (RNT PNG)</h4>
    <div class="row">
      <label>Load PNG (local file)</label>
      <input id="pngFile" type="file" accept="image/png,image/jpeg" />
    </div>
    <div class="row">
      <label>…or Image URL</label>
      <input id="imgUrl" type="text" placeholder="https://your-server/rnt.png" />
      <button class="btn" id="btnLoadUrl">Load</button>
    </div>
    <div class="row">
      <label>Image natural size (auto)</label>
      <div class="small" id="imgSize">—</div>
    </div>

    <div class="hr"></div>
    <h4>2) Classification rules (editable)</h4>
    <div class="small">Set how Zones A–D are derived from energy inputs. You can tune these thresholds anytime.</div>
    <div class="row">
      <label>Reliability (0–100) thresholds</label>
      <div class="small">A ≥ <input id="thrA" type="number" min="0" max="100" value="80" style="width:60px"> | B ≥ <input id="thrB" type="number" min="0" max="100" value="50" style="width:60px"> | C ≥ <input id="thrC" type="number" min="0" max="100" value="20" style="width:60px"></div>
    </div>
    <details style="margin-top:6px">
      <summary>Rule logic (click to view)</summary>
      <div class="small" style="margin-top:6px">
        <strong>Inputs per site</strong>: <em>energy_type</em> (grid | mini-grid | generator | solar | none), <em>reliability</em> (0–100), optional <em>hours_per_day</em>.<br>
        <strong>Default mapping</strong> (you can modify in code or use thresholds above):
        <ul>
          <li>Zone A: (energy_type ∈ {grid, mini-grid}) and reliability ≥ A threshold</li>
          <li>Zone B: (energy_type ∈ {grid, mini-grid}) and reliability ≥ B threshold</li>
          <li>Zone C: (energy_type ∈ {generator, solar}) or reliability ≥ C threshold</li>
          <li>Zone D: none or reliability &lt; C threshold</li>
        </ul>
      </div>
    </details>

    <div class="hr"></div>
    <h4>3) Data</h4>
    <div class="row">
      <label>Import CSV (x,y in image coords)</label>
      <input id="csvFile" type="file" accept=".csv" />
    </div>
    <div class="row">
      <button class="btn" id="btnExportCsv">Export CSV</button>
      <button class="btn" id="btnExportGeoJson">Export GeoJSON</button>
      <button class="btn" id="btnClear">Clear All</button>
    </div>
    <div class="small">CSV columns: name, x, y, energy_type, reliability, hours_per_day, notes</div>

    <div class="hr"></div>
    <h4>4) Tools</h4>
    <div class="row">
      <button class="btn" id="btnAdd">Add Point (click map)</button>
      <button class="btn" id="btnDrawLine">Draw Grid Line</button>
      <button class="btn" id="btnStopDraw">Stop Drawing</button>
    </div>
    <div class="row">
      <label>Filter by Zone</label>
      <select id="zoneFilter">
        <option value="all">All</option>
        <option value="A">Zone A</option>
        <option value="B">Zone B</option>
        <option value="C">Zone C</option>
        <option value="D">Zone D</option>
      </select>
    </div>

    <div class="hr"></div>
    <div class="small">Tip: this viewer uses <span class="pill">Leaflet CRS.Simple</span>. Coordinates are in image pixels: (x = column, y = row). If you later obtain GeoJSON for provinces/municipalities, we can georeference with a proper CRS.</div>
  </div>

  <div class="legend" id="legend">
    <div style="font-weight:600; margin-bottom:6px">Legend</div>
    <div class="item"><span class="swatch" style="background:#16a34a"></span> Zone A (High availability)</div>
    <div class="item"><span class="swatch" style="background:#3b82f6"></span> Zone B (Good)</div>
    <div class="item"><span class="swatch" style="background:#f59e0b"></span> Zone C (Limited)</div>
    <div class="item"><span class="swatch" style="background:#ef4444"></span> Zone D (None / very low)</div>
    <div class="item"><span class="swatch" style="background:#64748b"></span> Grid lines / sketches</div>
  </div>

  <script>
    // --- Map init with CRS.Simple (image pixel space) ---
    const map = L.map('map', {
      crs: L.CRS.Simple,
      zoomControl: true,
      minZoom: -3
    });

    // Default empty bounds until an image is loaded
    let imageLayer = null;
    let imgNatural = { w: 2000, h: 1200 }; // fallback
    function fitToImage() {
      const bounds = [[0,0], [imgNatural.h, imgNatural.w]]; // y,x
      map.setMaxBounds(bounds);
      map.fitBounds(bounds);
      return bounds;
    }
    fitToImage();

    // -- Drawing layers
    const pointsLayer = L.layerGroup().addTo(map);
    const linesLayer = L.layerGroup().addTo(map);

    // Colors per Zone
    const ZCOL = { A: '#16a34a', B: '#3b82f6', C: '#f59e0b', D: '#ef4444' };

    // State
    let addingPoint = false;
    let drawControl = null;
    let currentDraw = null;
    let data = []; // {name,x,y,energy_type,reliability,hours_per_day,notes,zone}

    // Classification thresholds
    const thrA = document.getElementById('thrA');
    const thrB = document.getElementById('thrB');
    const thrC = document.getElementById('thrC');

    function classify(rec) {
      const rel = Number(rec.reliability || 0);
      const t = (rec.energy_type||'').toLowerCase();
      const A = Number(thrA.value||80), B = Number(thrB.value||50), C = Number(thrC.value||20);
      if ((t==='grid' || t==='mini-grid') && rel >= A) return 'A';
      if ((t==='grid' || t==='mini-grid') && rel >= B) return 'B';
      if (t==='generator' || t==='solar' || rel >= C) return 'C';
      return 'D';
    }

    function markerFor(rec) {
      const zone = rec.zone || classify(rec);
      const color = ZCOL[zone] || '#000';
      const m = L.circleMarker([rec.y, rec.x], {
        radius: 6,
        weight: 2,
        color: '#111827',
        fillColor: color,
        fillOpacity: 0.9
      });
      const html = `
        <div style="min-width:220px">
          <div style="font-weight:700; margin-bottom:4px">${escapeHtml(rec.name||'Unnamed')}</div>
          <div><span class="pill">Zone ${zone}</span> • <strong>${escapeHtml(rec.energy_type||'?')}</strong> • Reliability: <strong>${rec.reliability ?? '?'}</strong></div>
          ${rec.hours_per_day?`<div>Hours/day: <strong>${rec.hours_per_day}</strong></div>`:''}
          ${rec.notes?`<div style="margin-top:4px; white-space:pre-wrap">${escapeHtml(rec.notes)}</div>`:''}
          <div class="hr"></div>
          <button class="leaflet-popup-close-btn" style="position:static;float:none" onclick="window.__editPoint('${rec.__id}')">Edit</button>
          <button class="leaflet-popup-close-btn" style="position:static;float:none;margin-left:8px" onclick="window.__deletePoint('${rec.__id}')">Delete</button>
        </div>`;
      m.bindPopup(html);
      return m;
    }

    function refreshPoints() {
      pointsLayer.clearLayers();
      const f = document.getElementById('zoneFilter').value;
      data.forEach(rec => {
        rec.zone = classify(rec);
        if (f==='all' || rec.zone===f) {
          const m = markerFor(rec);
          m.addTo(pointsLayer);
        }
      });
    }

    function addPointAt(latlng, prefill={}) {
      const id = crypto.randomUUID();
      const rec = Object.assign({ __id:id, name:'', x:latlng.lng, y:latlng.lat, energy_type:'grid', reliability:80, hours_per_day:'', notes:'' }, prefill);
      data.push(rec);
      openEditor(rec);
    }

    function openEditor(rec) {
      const form = document.createElement('div');
      form.innerHTML = `
        <div style="padding:6px 0; display:grid; grid-template-columns: 1fr; gap:6px; width:260px">
          <label>Name<input id="f_name" value="${escapeAttr(rec.name||'')}"/></label>
          <label>X (px)<input id="f_x" type="number" step="0.01" value="${Number(rec.x).toFixed(2)}"/></label>
          <label>Y (px)<input id="f_y" type="number" step="0.01" value="${Number(rec.y).toFixed(2)}"/></label>
          <label>Energy type
            <select id="f_type">
              ${['grid','mini-grid','generator','solar','none'].map(v=>`<option ${rec.energy_type===v?'selected':''}>${v}</option>`).join('')}
            </select>
          </label>
          <label>Reliability (0–100)<input id="f_rel" type="number" min="0" max="100" value="${Number(rec.reliability||0)}"/></label>
          <label>Hours per day (optional)<input id="f_hpd" type="number" min="0" max="24" value="${Number(rec.hours_per_day||'')}"/></label>
          <label>Notes<textarea id="f_notes">${escapeHtml(rec.notes||'')}</textarea></label>
          <div style="display:flex; gap:8px; margin-top:6px">
            <button class="btn primary" id="save">Save</button>
            <button class="btn" id="cancel">Cancel</button>
          </div>
        </div>`;
      const popup = L.popup().setLatLng([rec.y, rec.x]).setContent(form).openOn(map);
      form.querySelector('#save').onclick = () => {
        rec.name = form.querySelector('#f_name').value.trim();
        rec.x = Number(form.querySelector('#f_x').value);
        rec.y = Number(form.querySelector('#f_y').value);
        rec.energy_type = form.querySelector('#f_type').value;
        rec.reliability = Number(form.querySelector('#f_rel').value);
        rec.hours_per_day = form.querySelector('#f_hpd').value;
        rec.notes = form.querySelector('#f_notes').value;
        refreshPoints();
        map.closePopup(popup);
      };
      form.querySelector('#cancel').onclick = () => map.closePopup(popup);
    }

    window.__editPoint = function(id){
      const rec = data.find(d=>d.__id===id); if(!rec) return;
      openEditor(rec);
    }
    window.__deletePoint = function(id){
      const i = data.findIndex(d=>d.__id===id); if(i>=0){ data.splice(i,1); refreshPoints(); }
    }

    // Add point mode
    map.on('click', (e) => {
      if (!addingPoint) return;
      addPointAt(e.latlng);
    });

    // Buttons
    document.getElementById('btnAdd').onclick = () => { addingPoint = !addingPoint; toggleAddBtn(); };
    function toggleAddBtn(){
      document.getElementById('btnAdd').classList.toggle('primary', addingPoint);
      document.getElementById('btnAdd').textContent = addingPoint? 'Adding… (click map)' : 'Add Point (click map)';
    }

    // Draw lines (for transmission/backbone sketch)
    const drawOptions = {
      polyline: { shapeOptions: { color: '#64748b', weight: 3, opacity: 0.9 } },
      polygon: false, rectangle: false, circle: false, circlemarker: false, marker: false
    };
    document.getElementById('btnDrawLine').onclick = () => {
      if (currentDraw) currentDraw.disable();
      currentDraw = new L.Draw.Polyline(map, drawOptions.polyline);
      currentDraw.enable();
    };
    document.getElementById('btnStopDraw').onclick = () => { if (currentDraw) currentDraw.disable(); currentDraw=null; };
    map.on(L.Draw.Event.CREATED, function (e) {
      if (e.layerType === 'polyline') {
        linesLayer.addLayer(e.layer);
      }
    });

    // Zone filter
    document.getElementById('zoneFilter').onchange = refreshPoints;

    // CSV import/export
    document.getElementById('csvFile').addEventListener('change', async (ev) => {
      const f = ev.target.files?.[0]; if(!f) return;
      const text = await f.text();
      const rows = parseCSV(text);
      // Expect header: name,x,y,energy_type,reliability,hours_per_day,notes
      const header = rows.shift() || [];
      const idx = (k) => header.findIndex(h => h.trim().toLowerCase()===k);
      const iName = idx('name'), iX=idx('x'), iY=idx('y'), iType=idx('energy_type'), iRel=idx('reliability'), iH=idx('hours_per_day'), iN=idx('notes');
      if (iName<0 || iX<0 || iY<0 || iType<0 || iRel<0) {
        alert('Missing required headers. Need: name,x,y,energy_type,reliability[,hours_per_day,notes]');
        return;
      }
      rows.forEach(r => {
        if (!r.length) return;
        const rec = {
          __id: crypto.randomUUID(),
          name: r[iName] || '',
          x: Number(r[iX]||0),
          y: Number(r[iY]||0),
          energy_type: (r[iType]||'').toLowerCase(),
          reliability: Number(r[iRel]||0),
          hours_per_day: r[iH]||'',
          notes: r[iN]||''
        };
        data.push(rec);
      });
      refreshPoints();
    });

    document.getElementById('btnExportCsv').onclick = () => {
      const header = ['name','x','y','energy_type','reliability','hours_per_day','notes','zone'];
      const lines = [header.join(',')].concat(
        data.map(d => header.map(k => csvEscape(String(d[k] ?? ''))).join(','))
      );
      downloadText('rnt_energy_points.csv', lines.join('\n'));
    };
    document.getElementById('btnExportGeoJson').onclick = () => {
      const fc = {
        type: 'FeatureCollection',
        features: data.map(d => ({
          type: 'Feature',
          properties: {
            name: d.name, energy_type: d.energy_type, reliability: d.reliability,
            hours_per_day: d.hours_per_day, notes: d.notes, zone: classify(d)
          },
          geometry: { type: 'Point', coordinates: [d.x, d.y] } // image coords
        }))
      };
      downloadText('rnt_energy_points.geojson', JSON.stringify(fc, null, 2));
    };

    document.getElementById('btnClear').onclick = () => {
      if (!confirm('Remove all points and lines?')) return;
      data = []; refreshPoints(); linesLayer.clearLayers();
    };

    // Image loading
    const pngFile = document.getElementById('pngFile');
    const imgUrl = document.getElementById('imgUrl');
    const btnLoadUrl = document.getElementById('btnLoadUrl');
    const imgSize = document.getElementById('imgSize');

    pngFile.addEventListener('change', ev => {
      const f = ev.target.files?.[0]; if(!f) return;
      const reader = new FileReader();
      reader.onload = () => tryLoadImage(reader.result);
      reader.readAsDataURL(f);
    });
    btnLoadUrl.onclick = () => {
      const u = imgUrl.value.trim(); if (!u) return;
      tryLoadImage(u);
    };

    async function tryLoadImage(src) {
      const im = new Image();
      im.onload = () => {
        imgNatural = { w: im.naturalWidth, h: im.naturalHeight };
        imgSize.textContent = `${imgNatural.w} × ${imgNatural.h} px`;
        const bounds = fitToImage();
        if (imageLayer) map.removeLayer(imageLayer);
        imageLayer = L.imageOverlay(src, bounds).addTo(map);
      };
      im.onerror = () => alert('Failed to load image. Check the URL/file.');
      im.src = src;
    }

    // Helpers
    function escapeHtml(s){
      return String(s).replace(/[&<>"]g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;'}[c]));
    }
    function escapeAttr(s){
      return String(s).replace(/"/g, '&quot;');
    }
    function parseCSV(text){
      // Tiny CSV parser for simple cases (handles quotes)
      const lines = text.replace(/\r\n?/g,'\n').split('\n');
      const rows=[]; let cur=[], val='', q=false;
      for (let i=0;i<lines.length;i++){
        const line = lines[i];
        for (let j=0;j<line.length;j++){
          const ch = line[j];
          if (q){
            if (ch==='"'){
              if (line[j+1]==='"'){ val+='"'; j++; }
              else { q=false; }
            } else val+=ch;
          } else {
            if (ch==='"') q=true;
            else if (ch===','){ cur.push(val); val=''; }
            else val+=ch;
          }
        }
        cur.push(val); val=''; rows.push(cur); cur=[];
      }
      // Trim trailing empty lines
      while (rows.length && rows[rows.length-1].every(x=>x==='')) rows.pop();
      return rows;
    }
    function csvEscape(s){
      if (/[",\n]/.test(s)) return '"'+s.replace(/"/g,'""')+'"';
      return s;
    }
    function downloadText(filename, text){
      const blob = new Blob([text], {type:'text/plain'});
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = filename; a.click();
      setTimeout(()=>URL.revokeObjectURL(a.href), 5000);
    }
  </script>
</body>
</html>
